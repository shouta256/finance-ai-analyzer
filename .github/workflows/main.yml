name: Web CI (Vercel) + Backend tests

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
  workflow_dispatch: {}

permissions:
  contents: read

jobs:
  web-ci:
    name: Web - Lint/Test/Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          # Use the version declared in package.json `packageManager` (pnpm@9.x)
          run_install: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'
          cache-dependency-path: pnpm-lock.yaml

      - name: Install deps (apps/web)
        shell: bash
        run: |
          set -euo pipefail
          if [ -f apps/web/pnpm-lock.yaml ]; then
            echo "Found apps/web/pnpm-lock.yaml -> using --frozen-lockfile"
            pnpm -C apps/web install --frozen-lockfile
          else
            echo "apps/web/pnpm-lock.yaml not found -> using --no-frozen-lockfile"
            pnpm -C apps/web install --no-frozen-lockfile
          fi

      - name: Run unit tests (apps/web)
        run: pnpm -C apps/web test

      - name: Build (apps/web)
        run: pnpm -C apps/web build


  backend-tests:
    name: Backend - Unit tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Java 21
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Run tests (ledger-svc)
        run: ./apps/ledger-svc/gradlew -p apps/ledger-svc test

  deploy-lambda:
    name: Deploy Lambda (hello-http)
    needs: [web-ci, backend-tests]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Build Lambda layer (pg)
        run: |
          set -euo pipefail
          rm -rf dist
          mkdir -p dist/layer/nodejs
          npm install pg --prefix dist/layer/nodejs
          (cd dist/layer && zip -r ../pg-layer.zip nodejs)

      - name: Package Lambda source
        run: |
          set -euo pipefail
          mkdir -p dist/lambda
          cp infra/lambda/index.js dist/lambda/
          cp -R infra/lambda/src dist/lambda/
          cp -R infra/lambda/certs dist/lambda/
          # Create package.json and install dependencies inside the target directory
          (cd dist/lambda && \
            npm init -y && \
            npm install aws-sdk jose && \
            zip -r ../lambda.zip ./*)

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: us-east-1

      - name: Publish pg layer
        id: publish_layer
        run: |
          ARCH=${{ vars.LAMBDA_ARCHITECTURE || 'x86_64' }}
          LAYER_ARN=$(aws lambda publish-layer-version \
            --layer-name safepocket-pg-node20 \
            --description "pg client for Safepocket" \
            --compatible-runtimes nodejs20.x \
            --compatible-architectures ${ARCH} \
            --zip-file fileb://dist/pg-layer.zip \
            --query 'LayerVersionArn' \
            --output text)
          echo "layer_arn=$LAYER_ARN" >> "$GITHUB_OUTPUT"

      - name: Update Lambda code
        run: |
          FUNCTION_NAME=${{ secrets.LAMBDA_FUNCTION_NAME || 'hello-http' }}
          aws lambda update-function-code \
            --function-name "$FUNCTION_NAME" \
            --zip-file fileb://dist/lambda.zip

      - name: Wait for Lambda to stabilize
        run: |
          FUNCTION_NAME=${{ secrets.LAMBDA_FUNCTION_NAME || 'hello-http' }}
          # Wait until the previous update has completed to avoid ResourceConflictException
          aws lambda wait function-updated --function-name "$FUNCTION_NAME"

      - name: Attach latest layer
        run: |
          FUNCTION_NAME=${{ secrets.LAMBDA_FUNCTION_NAME || 'hello-http' }}
          aws lambda update-function-configuration \
            --function-name "$FUNCTION_NAME" \
            --layers ${{ steps.publish_layer.outputs.layer_arn }}

      - name: Wait for layer attachment to propagate
        run: |
          FUNCTION_NAME=${{ secrets.LAMBDA_FUNCTION_NAME || 'hello-http' }}
          aws lambda wait function-updated --function-name "$FUNCTION_NAME"

      - name: Refresh Lambda environment (CONFIG_BUMP)
        run: |
          set -eo pipefail
          FUNCTION_NAME=${{ secrets.LAMBDA_FUNCTION_NAME || 'hello-http' }}
          CONFIG_BUMP=$(date +%s)
          NODE_PATH_VALUE="/opt/nodejs/node_modules:/opt/nodejs/node20/node_modules"
          EXISTING_ENV=$(aws lambda get-function-configuration \
            --function-name "$FUNCTION_NAME" \
            --query 'Environment.Variables' \
            --output json)
          
          # Only update database config if secrets are provided
          DB_HOST='${{ secrets.DB_HOST }}'
          DB_USER='${{ secrets.DB_USER }}'
          DB_PASSWORD='${{ secrets.DB_PASSWORD }}'
          DB_NAME='${{ secrets.DB_NAME }}'
          DB_PORT='${{ secrets.DB_PORT || '5432' }}'
          DB_SSLMODE='${{ secrets.DB_SSLMODE || 'require' }}'
          
          if [ -n "${DB_HOST:-}" ] && [ -n "${DB_USER:-}" ] && [ -n "${DB_PASSWORD:-}" ] && [ -n "${DB_NAME:-}" ]; then
            echo "Updating Lambda database configuration..."
            # URL-encode the password to handle special characters (using single quotes to prevent variable expansion)
            ENCODED_PASSWORD=$(echo -n "${DB_PASSWORD}" | jq -sRr @uri)
            DATABASE_URL="postgresql://${DB_USER}:${ENCODED_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}?sslmode=${DB_SSLMODE}"
            
            UPDATED_ENV=$(echo "$EXISTING_ENV" | jq -c \
              --arg node_path "$NODE_PATH_VALUE" \
              --arg config_bump "$CONFIG_BUMP" \
              --arg database_url "$DATABASE_URL" \
              --arg db_host "$DB_HOST" \
              --arg db_port "$DB_PORT" \
              --arg db_name "$DB_NAME" \
              --arg db_user "$DB_USER" \
              --arg db_password "$DB_PASSWORD" \
              --arg db_sslmode "$DB_SSLMODE" \
              '
              (. // {}) |
              .NODE_PATH = $node_path |
              .CONFIG_BUMP = $config_bump |
              .DATABASE_URL = $database_url |
              .DB_HOST = $db_host |
              .DB_PORT = $db_port |
              .DB_NAME = $db_name |
              .DB_USER = $db_user |
              .DB_PASSWORD = $db_password |
              .DB_SSLMODE = $db_sslmode
            ')
          else
            echo "Database secrets not configured, preserving existing database environment variables"
            UPDATED_ENV=$(echo "$EXISTING_ENV" | jq -c \
              --arg node_path "$NODE_PATH_VALUE" \
              --arg config_bump "$CONFIG_BUMP" \
              '
              (. // {}) |
              .NODE_PATH = $node_path |
              .CONFIG_BUMP = $config_bump
            ')
          fi
          
          ENV_PAYLOAD=$(jq -n --argjson vars "$UPDATED_ENV" '{Variables: $vars}')
          aws lambda update-function-configuration \
            --function-name "$FUNCTION_NAME" \
            --environment "$ENV_PAYLOAD"
