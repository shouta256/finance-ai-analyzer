/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/auth/token": {
    /** Exchange Cognito authorization code or refresh token for Safepocket session */
    post: operations["exchangeAuthToken"];
  };
  "/plaid/link-token": {
    /** Create Plaid link token */
    post: operations["createPlaidLinkToken"];
  };
  "/plaid/exchange": {
    /** Exchange Plaid public token for access token */
    post: operations["exchangePlaidPublicToken"];
  };
  "/transactions/sync": {
    /** Trigger Plaid transaction sync */
    post: operations["triggerTransactionSync"];
  };
  "/transactions": {
    /** List transactions for a user and month */
    get: operations["listTransactions"];
  };
  "/transactions/{transactionId}": {
    /** Update selected properties of a transaction */
    patch: operations["updateTransaction"];
  };
  "/analytics/summary": {
    /** Retrieve monthly analytics summary */
    get: operations["getAnalyticsSummary"];
  };
  "/accounts": {
    /** List linked accounts for the authenticated user */
    get: operations["listAccounts"];
  };
  "/rag/search": {
    /** Search transactions with structured filters and semantic ranking */
    post: operations["ragSearch"];
  };
  "/rag/summaries": {
    /** Retrieve lightweight month, category, and merchant summaries */
    get: operations["ragSummaries"];
  };
  "/rag/aggregate": {
    /** Aggregate transactions for a custom window and granularity */
    post: operations["ragAggregate"];
  };
  "/users/{userId}": {
    /** Delete user and purge associated data */
    delete: operations["deleteUser"];
  };
  "/ai/chat": {
    /** Send a chat message to AI assistant */
    post: operations["sendAiChatMessage"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    AuthTokenRequest: {
      /**
       * @description OAuth2 grant type to execute (authorization_code or refresh_token)
       * @enum {string}
       */
      grantType: "authorization_code" | "refresh_token";
      /** @description Authorization code returned from Cognito Hosted UI callback (required for authorization_code grant) */
      code?: string;
      /**
       * Format: uri
       * @description Redirect URI registered in Cognito and used during authorization (required for authorization_code grant)
       */
      redirectUri?: string;
      /** @description PKCE code_verifier used during authorization (optional) */
      codeVerifier?: string;
      /** @description Refresh token issued by Cognito (required for refresh_token grant) */
      refreshToken?: string;
    };
    AuthTokenResponse: {
      /** @description Access token issued by Cognito (use in Authorization header) */
      accessToken: string;
      /** @description ID token issued by Cognito (may be absent if scope excludes openid) */
      idToken?: string | null;
      /** @description Refresh token for obtaining new access tokens */
      refreshToken?: string | null;
      /**
       * Format: int32
       * @description Token lifetime in seconds
       */
      expiresIn: number;
      /** @description Token type (typically Bearer) */
      tokenType: string;
      /** @description Granted scopes from Cognito */
      scope?: string | null;
      /**
       * Format: uuid
       * @description Authenticated user identifier derived from token subject
       */
      userId?: string | null;
      /** @description Request trace identifier for auditing */
      traceId: string;
    };
    AccountsListResponse: {
      /** @description ISO 4217 currency code for balances */
      currency: string;
      /**
       * Format: double
       * @description Sum of balances across all accounts
       */
      totalBalance: number;
      accounts: components["schemas"]["Account"][];
      /** @description Request trace identifier for auditing */
      traceId: string;
    };
    Account: {
      /** Format: uuid */
      id: string;
      name: string;
      institution: string;
      /** @description Account type (checking, savings, credit, etc.) */
      type?: string | null;
      /**
       * Format: double
       * @description Current account balance
       */
      balance: number;
      currency: string;
      /**
       * Format: date-time
       * @description Timestamp when the account was first recorded
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp of the latest transaction observed for this account
       */
      lastTransactionAt?: string | null;
      /**
       * Format: date-time
       * @description When the underlying financial institution link was established
       */
      linkedAt?: string | null;
    };
    PlaidLinkTokenResponse: {
      /** @description Plaid Link token */
      linkToken: string;
      /**
       * Format: date-time
       * @description Expiration timestamp for the link token
       */
      expiration: string;
      /** @description Plaid request identifier */
      requestId: string;
    };
    PlaidExchangeRequest: {
      /** @description Plaid public token obtained from Link */
      publicToken: string;
    };
    PlaidExchangeResponse: {
      /** @description Plaid item identifier associated with the user */
      itemId: string;
      /**
       * @description Status of exchange request
       * @enum {string}
       */
      status: "SUCCESS";
      /** @description Plaid request identifier */
      requestId: string;
    };
    TransactionsSyncRequest: {
      /** @description Cursor from last sync to request incremental updates */
      cursor?: string;
      /**
       * @description Force a full backfill of transactions
       * @default false
       */
      forceFullSync?: boolean;
      /**
       * @description When true, load demo accounts and sample transactions instead of calling Plaid
       * @default false
       */
      demoSeed?: boolean;
    };
    TransactionsSyncResponse: {
      /** @enum {string} */
      status: "STARTED" | "COMPLETED";
      /**
       * Format: int32
       * @description Number of transactions queued for processing
       */
      syncedCount: number;
      /**
       * Format: int32
       * @description Number of transactions remaining in backlog
       */
      pendingCount: number;
      /** @description Identifier for correlating async sync operations */
      traceId: string;
    };
    TransactionsListResponse: {
      /** @description Requested month window (YYYY-MM) */
      month: string;
      transactions: components["schemas"]["Transaction"][];
      /** @description Request trace identifier for auditing */
      traceId: string;
    };
    Transaction: {
      /** Format: uuid */
      id: string;
      /** Format: uuid */
      userId: string;
      /** Format: uuid */
      accountId: string;
      merchantName: string;
      /** Format: double */
      amount: number;
      currency: string;
      /** Format: date-time */
      occurredAt: string;
      /** Format: date-time */
      authorizedAt?: string | null;
      pending: boolean;
      category: string;
      description?: string | null;
      anomalyScore?: components["schemas"]["AnomalyScore"];
    };
    TransactionUpdateRequest: {
      /** @description New category name to assign */
      category?: string;
      /** @description Analyst notes for the transaction */
      notes?: string;
    };
    AnalyticsSummaryResponse: {
      /** @description Month covered by the analytics (YYYY-MM) */
      month: string;
      totals: components["schemas"]["AnalyticsTotals"];
      byCategory: components["schemas"]["CategoryBreakdown"][];
      topMerchants: components["schemas"]["MerchantBreakdown"][];
      anomalies: components["schemas"]["AnomalyInsight"][];
      aiHighlight: components["schemas"]["AiHighlight"];
      /** @description Identifier for correlating AI computations */
      traceId: string;
    };
    AnalyticsTotals: {
      /** Format: double */
      income: number;
      /** Format: double */
      expense: number;
      /** Format: double */
      net: number;
    };
    CategoryBreakdown: {
      category: string;
      /** Format: double */
      amount: number;
      /**
       * Format: double
       * @description Portion of expense represented by the category
       */
      percentage: number;
    };
    MerchantBreakdown: {
      merchant: string;
      /** Format: double */
      amount: number;
      /** Format: int32 */
      transactionCount: number;
    };
    AnomalyScore: {
      /** @enum {string} */
      method: "Z_SCORE" | "IQR";
      /**
       * Format: double
       * @description Absolute difference compared to typical spend for this merchant/category
       */
      deltaAmount: number;
      /**
       * Format: double
       * @description Percentage share of the month's total expenses accounted for by this transaction
       */
      budgetImpactPercent: number;
      commentary?: string | null;
    };
    AnomalyInsight: {
      /** Format: uuid */
      transactionId: string;
      /** @enum {string} */
      method: "Z_SCORE" | "IQR";
      /** Format: double */
      amount: number;
      /**
       * Format: double
       * @description Absolute difference from typical spend for this merchant/category
       */
      deltaAmount: number;
      /**
       * Format: double
       * @description Percentage share of this month's total expenses
       */
      budgetImpactPercent: number;
      /** Format: date-time */
      occurredAt: string;
      merchantName: string;
      commentary?: string | null;
    };
    AiHighlight: {
      title: string;
      summary: string;
      /** @enum {string} */
      sentiment: "POSITIVE" | "NEUTRAL" | "NEGATIVE";
      /** @description Optional next-best-actions surfaced by AI */
      recommendations?: string[];
    };
    ErrorResponse: {
      error: {
        code: string;
        message: string;
        details?: {
          [key: string]: unknown;
        };
      };
      traceId: string;
    };
    AiChatRequest: {
      /**
       * Format: uuid
       * @description Existing conversation identifier; when omitted a new conversation is started.
       */
      conversationId?: string;
      /** @description User's message content */
      message: string;
      /**
       * Format: uuid
       * @description Trim the stored conversation from this message (inclusive) before appending the new user message.
       */
      truncateFromMessageId?: string;
    };
    AiChatMessage: {
      /** Format: uuid */
      id: string;
      /** @enum {string} */
      role: "USER" | "ASSISTANT";
      content: string;
      /** Format: date-time */
      createdAt: string;
    };
    AiChatResponse: {
      /** Format: uuid */
      conversationId: string;
      messages: components["schemas"]["AiChatMessage"][];
      traceId: string;
    };
    RagSearchRequest: {
      /** @description Natural language query for semantic embedding search */
      q?: string;
      /**
       * Format: date
       * @description Inclusive start date filter (YYYY-MM-DD)
       */
      from?: string;
      /**
       * Format: date
       * @description Inclusive end date filter (YYYY-MM-DD)
       */
      to?: string;
      /** @description Optional list of category names to include */
      categories?: string[];
      /**
       * Format: int32
       * @description Minimum amount in cents
       */
      amountMin?: number;
      /**
       * Format: int32
       * @description Maximum amount in cents
       */
      amountMax?: number;
      /**
       * Format: int32
       * @description Maximum number of candidate rows to evaluate before compression
       */
      topK?: number;
      /** @description Reserved for future selective field inclusion */
      fields?: string[];
    };
    RagSearchResponse: {
      /** @description Up to 20 CSV rows (no header) using compact aliases (t*, m*, category codes) */
      rowsCsv: string;
      dict: {
        /** @description Maps merchant short codes (m1..) to display names */
        merchants: {
          [key: string]: string;
        };
        /** @description Maps category short codes to canonical labels */
        categories: {
          [key: string]: string;
        };
      };
      stats: components["schemas"]["RagSearchStats"];
      /** @description Correlation identifier echoed from TraceIdFilter */
      traceId?: string;
      /** @description Session identifier to reuse for follow-up delta queries */
      chatId: string;
    };
    RagSearchStats: {
      /**
       * Format: int32
       * @description Number of rows included in rowsCsv
       */
      count: number;
      /**
       * Format: int64
       * @description Total amount (cents) across returned rows
       */
      sum: number;
      /**
       * Format: int64
       * @description Average amount (cents) across returned rows
       */
      avg: number;
    };
    RagSummariesResponse: {
      /** @description Month window represented (YYYY-MM) */
      month: string;
      totals: components["schemas"]["RagTotals"];
      categories: components["schemas"]["RagCategoryBreakdown"][];
      merchants: components["schemas"]["RagMerchantBreakdown"][];
      /** @description Correlation identifier for auditing */
      traceId?: string;
    };
    RagTotals: {
      /**
       * Format: int64
       * @description Total inflow in cents
       */
      income: number;
      /**
       * Format: int64
       * @description Total outflow in cents (negative)
       */
      expense: number;
      /**
       * Format: int64
       * @description Net income-expense in cents
       */
      net: number;
    };
    RagCategoryBreakdown: {
      /** @description Short category alias (eo, gr, etc.) */
      code: string;
      label: string;
      /** Format: int32 */
      count: number;
      /** Format: int64 */
      sum: number;
      /** Format: int64 */
      avg: number;
    };
    RagMerchantBreakdown: {
      /** @description Merchant identifier (UUID as string) */
      merchantId: string;
      label: string;
      /** Format: int32 */
      count: number;
      /** Format: int64 */
      sum: number;
    };
    RagAggregateRequest: {
      /**
       * Format: date
       * @description Inclusive lower bound (optional)
       */
      from?: string;
      /**
       * Format: date
       * @description Inclusive upper bound (optional)
       */
      to?: string;
      /**
       * @description Grouping dimension for aggregation
       * @enum {string}
       */
      granularity: "category" | "merchant" | "month";
    };
    RagAggregateResponse: {
      /** @description Echoed grouping dimension */
      granularity: string;
      /** Format: date */
      from?: string | null;
      /** Format: date */
      to?: string | null;
      buckets: components["schemas"]["RagAggregateBucket"][];
      timeline?: components["schemas"]["RagTimelinePoint"][];
      /** @description Correlation identifier */
      traceId?: string;
      /** @description Session identifier reused across aggregate/search requests */
      chatId: string;
    };
    RagAggregateBucket: {
      key: string;
      label: string;
      /** Format: int32 */
      count: number;
      /** Format: int64 */
      sum: number;
      /** Format: int64 */
      avg: number;
    };
    RagTimelinePoint: {
      /** @description Aggregation bucket label (YYYY-MM) */
      bucket: string;
      /** Format: int32 */
      count: number;
      /** Format: int64 */
      sum: number;
    };
  };
  responses: {
    /** @description Error response wrapper */
    ErrorResponse: {
      content: {
        "application/json": components["schemas"]["ErrorResponse"];
      };
    };
  };
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /** Exchange Cognito authorization code or refresh token for Safepocket session */
  exchangeAuthToken: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["AuthTokenRequest"];
      };
    };
    responses: {
      /** @description Tokens issued successfully */
      200: {
        content: {
          "application/json": components["schemas"]["AuthTokenResponse"];
        };
      };
      default: components["responses"]["ErrorResponse"];
    };
  };
  /** Create Plaid link token */
  createPlaidLinkToken: {
    responses: {
      /** @description Link token created */
      200: {
        content: {
          "application/json": components["schemas"]["PlaidLinkTokenResponse"];
        };
      };
      default: components["responses"]["ErrorResponse"];
    };
  };
  /** Exchange Plaid public token for access token */
  exchangePlaidPublicToken: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["PlaidExchangeRequest"];
      };
    };
    responses: {
      /** @description Exchange recorded successfully */
      200: {
        content: {
          "application/json": components["schemas"]["PlaidExchangeResponse"];
        };
      };
      default: components["responses"]["ErrorResponse"];
    };
  };
  /** Trigger Plaid transaction sync */
  triggerTransactionSync: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["TransactionsSyncRequest"];
      };
    };
    responses: {
      /** @description Sync started */
      202: {
        content: {
          "application/json": components["schemas"]["TransactionsSyncResponse"];
        };
      };
      default: components["responses"]["ErrorResponse"];
    };
  };
  /** List transactions for a user and month */
  listTransactions: {
    parameters: {
      query: {
        /** @description Month to filter transactions by (YYYY-MM) */
        month: string;
        /** @description Filter by account identifier */
        accountId?: string;
      };
    };
    responses: {
      /** @description Transactions retrieved */
      200: {
        content: {
          "application/json": components["schemas"]["TransactionsListResponse"];
        };
      };
      default: components["responses"]["ErrorResponse"];
    };
  };
  /** Update selected properties of a transaction */
  updateTransaction: {
    parameters: {
      path: {
        transactionId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TransactionUpdateRequest"];
      };
    };
    responses: {
      /** @description Transaction updated */
      200: {
        content: {
          "application/json": components["schemas"]["Transaction"];
        };
      };
      default: components["responses"]["ErrorResponse"];
    };
  };
  /** Retrieve monthly analytics summary */
  getAnalyticsSummary: {
    parameters: {
      query: {
        /** @description Month to generate analytics for (YYYY-MM) */
        month: string;
        /** @description When true, request backend to generate AI summary via OpenAI. When false, backend returns lightweight/fallback summary. */
        generateAi?: boolean;
      };
    };
    responses: {
      /** @description Analytics summary retrieved */
      200: {
        content: {
          "application/json": components["schemas"]["AnalyticsSummaryResponse"];
        };
      };
      default: components["responses"]["ErrorResponse"];
    };
  };
  /** List linked accounts for the authenticated user */
  listAccounts: {
    responses: {
      /** @description Accounts retrieved */
      200: {
        content: {
          "application/json": components["schemas"]["AccountsListResponse"];
        };
      };
      default: components["responses"]["ErrorResponse"];
    };
  };
  /** Search transactions with structured filters and semantic ranking */
  ragSearch: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["RagSearchRequest"];
      };
    };
    responses: {
      /** @description Compressed transaction slice for conversational RAG */
      200: {
        content: {
          "application/json": components["schemas"]["RagSearchResponse"];
        };
      };
      default: components["responses"]["ErrorResponse"];
    };
  };
  /** Retrieve lightweight month, category, and merchant summaries */
  ragSummaries: {
    parameters: {
      query: {
        /** @description Month window to inspect (YYYY-MM) */
        month: string;
      };
    };
    responses: {
      /** @description Summary payload optimised for LLM consumption */
      200: {
        content: {
          "application/json": components["schemas"]["RagSummariesResponse"];
        };
      };
      default: components["responses"]["ErrorResponse"];
    };
  };
  /** Aggregate transactions for a custom window and granularity */
  ragAggregate: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["RagAggregateRequest"];
      };
    };
    responses: {
      /** @description Aggregated totals and timeline series */
      200: {
        content: {
          "application/json": components["schemas"]["RagAggregateResponse"];
        };
      };
      default: components["responses"]["ErrorResponse"];
    };
  };
  /** Delete user and purge associated data */
  deleteUser: {
    parameters: {
      path: {
        userId: string;
      };
    };
    responses: {
      /** @description User deleted */
      204: {
        content: never;
      };
      default: components["responses"]["ErrorResponse"];
    };
  };
  /** Send a chat message to AI assistant */
  sendAiChatMessage: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["AiChatRequest"];
      };
    };
    responses: {
      /** @description Chat response returned */
      200: {
        content: {
          "application/json": components["schemas"]["AiChatResponse"];
        };
      };
      default: components["responses"]["ErrorResponse"];
    };
  };
}
